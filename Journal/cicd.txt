								CI/CD




CI/CD is good because it automates the process of building, testing, and delivering software, enabling faster, safer, 
and more reliable releases.

Smaller incremental changes to code reduces risks of big failures. 

All team members work is integrated frequently. 



- A powerful tool!!! It Helps us build, test and release software applications much faster and much more reliably. 

- No more 'it works on my machine'. We will make sure it works everywhere!

- Uses 'Github actions'

- Automate development process, catch bugs early and deploy your applications with confidence.

- Workflows * Pipelines    > SYNONYMOUS 



							Introduction:


							What is it?


CI / CD = Continuous integration / Continuous deployment (or delivery)


							
							CI


	
CI: CI is the practice of frequently integrating code changes into a shared repository, where each integration is 
    automatically built and tested. This way, we can find and catch errors quickly, making the whole development 
    process smoother.

- Catch bugs early
- Ensure code is mergable and functional


CI ends after code is validated. Once you are happy, you can send a merge request forawrd.  


ONCE CODE HAS BEEN MERGED INTO MAIN BRANCH, THIS IS WHERE CD BEGINS.



							CD


Continuous Deployment (CD)
- Automatically builds, tests, and deploys all the way to production
- No manual approvals ‚Äî every successful commit goes live (if tests pass)

 

Continuous Delivery (CD)
- Automatically builds, tests, and delivers code to a staging or pre-production environment
- Manual approval is still required to deploy to production. 



Stage			Continuous Integration		Continuous Delivery		Continuous Deployment


Automated		build/test	‚úÖ		‚úÖ					‚úÖ

Deploy to		staging		‚ùå		‚úÖ					‚úÖ

Deploy to 		production	‚ùå		‚úÖ (manual approval)		‚úÖ (fully automated)

Rollback/Monitoring	‚ùå (not part of CI)		‚úÖ (optional/manual)		‚úÖ (often automated)



					When use Delivery and when use Deployment?

- Regulated / High risk apps (medical industry) 				> Delivery. We want human approval

- Apps that require fast iterations and have mature DevOps teams		> Deployment.
 



						The ci/cd PIPELINE


1. Developer pushes code to a feature branch
2. ‚ûú CI pipeline starts
    - Runs tests, linting, builds	# Once code pushed, it triggers automated build process. 
    - CI passes ‚úÖ			# Code compiled, built, ran, tested. 
					# When done system notifies if sucess or fail
				
3. Developer opens a Pull Request (PR)
4. Team reviews and approves the PR
5. Code is merged into main branch
6. ‚ûú CD pipeline starts
    - Builds production-ready artifact (e.g., Docker image)
    - Deploys to staging or production
    - Runs post-deploy tests or health checks

7. Post-deploy tests and health checks run
    - Smoke tests (e.g., "Does the app start?")
    - Endpoint checks (e.g., "/health" or "/api/status")
    - Integration tests (optional)
    - Monitoring tool pings (Prometheus, CloudWatch, etc.)

8. All checks pass ‚úÖ
    - Deployment is marked as **successful**
    - Monitoring confirms system is stable
    - Notifications are sent (Slack, email, etc.)

9. CD pipeline completes ‚úÖ
    - Artifacts are stored/tagged (e.g., Docker image v1.3.2)
    - Logs and metrics are archived
    - Deployment status visible in dashboard (GitHub Actions, ArgoCD, Jenkins, etc.)

10. Team is notified:
    - "‚úÖ Deployment successful to production"
    - Links to logs, monitoring dashboards, and release notes		# MONITORING AND LOGGING VERY IMPORTANT



							CI/CD Tools


1. Gitlab CI/CD. 		# Integrated right into Github. If using github, then likely will be using Gitlab. 

2. Jenkins			# Most popular CI/CD tool. Open source. Very powerful, can do anything. Complex.

3. circleci			# Cloud based CI/CD tool. Fast and simple. Integrates well with github and bit bucket. 

4. Travis CI			# Cloud based CI/CD. Integrates well with github. Simple and ease of use.

5. Github Actions		# Integrated directly deeply into github. This will be my focus. 







						Github Actions (In YAML files)






- Once code is commited onto github this is where github actions kick in!

- The github action workflow specifies what actions to take when certain events occur (like commit)

- github actions are specified in a YAML file.

						The github actions workflow

  Step 1: Build the code. Compiling code and resolving dependencies
  Step 2: Automated tests. Verify new code doesn't break anything. Any existing functinality not broken/features work.
  Step 3: Test outcome checked. If test passes workflow moves onto next step. If fails, process stops and devs notified.
  Step 4: If test+build successful, code is packaged. Usually it creates a new deploy version of product (docker img)
  Step 5: Packaged and deployed. This can be to staging/testing environment or even direct to production
  Step 6: Once pushed to production, you want to monitor and check logs to make sure everything is working well.  
 




					Github Actions: Continuous integration


- Automatically build and test code every time you push into repositary
- Run unit test on every pull request. Make sure any new code doesn't break existing functuality


					Github Actions: CD

- After code passes all tests, github actions can automatically deploy to production or any other environment. 
- Deploying application into cloud service like aws. Can be set to happen automatically.

					Github Actions: Automation

- Github actions can automate repetitive tasks in workflow like:
- Managing product board operations: moving cards or tasks between columns on github project board based on issues/PR.



						üì¶ What Is a Card?
	
A card is a visual representation of a GitHub Issue or Pull Request on a project board.

Each issue or pull request can be turned into a card.

Cards are placed into columns on a board to track progress.

You can move cards manually or automate it using GitHub Actions.



						üóÇÔ∏è What Is a Board?

A board is a project view ‚Äî like a digital kanban board ‚Äî used to organize tasks, issues, and PRs into different stages.


Example: A Simple GitHub Project Board

To Do üìù				 In Progress üöß				Done ‚úÖ
Issue #45: Fix login bug		PR #78: Add CI/CD		Issue #12: Update docs
Issue #53: Add footer UI		     ...					...





							YAML Syntax




- YAML (YAML ain't markup language)
- YAML is the language of devops. (kubernetes, ci/cd, docker compose, etc.)
- YAML is a way to write settings and instructions for programs in a format that‚Äôs easy for humans to read and write.

YAML is very simple. It works with:

 key : value

 lists: 
  - item 1
  - item 2
  - item 3

Nested elemenents (using 2 spaces)

parent:
  child : value



Essentially, yml is very easy to write. First of all it needs to be in a .yml or .yaml file. 

secondly you can write in:

key:value			lists			Nested elements
					
name: zak			fruits:			address:
job: DevOps			- apple			  street: 123 Downing Street
				- bannana		  city: London






						Workflow/Pipeline Syntax



You need a '.github/workflows/' directory. This is how github knows where the yaml files are located.


1. Create the workflows directory:

yourproject/.github/workflows/

# This is where the workflows will go.  



2. 						The YAML file structure:

---------------------------------------------------------------------------------------------------------------


name : Zaks CICD workflow			# helps you identify what workflow does

on: [push]					# This is a trigger. Events that trigger the workflow (push/pullrequest)

jobs: 						# Series of tasks that run as part of the workflow
						# Independent tasks that run in parallel or sequentially. 
						# Each job runs on a virtual machine (hence we choose the OS below)


  build: 					# We have a single job called build

    runs-on: ubuntu-latest 			# each job runs in own virtual environment and OS is configured

    steps: 					# steps are individual tasks that will run in a sequence

    - name: Checkout code			# arbitary. Helps humans understand what the step is doing. 
      uses: actions/checkout@v2			# uses a pre-built action. This action is usually the first. Important  
						# It downloads your code into VM so rest of workflow can access it.
						# github workflows has marketplace of resuable/community created actions

    - name: Set up Node.js			
      uses: actions/setup-node@v2		# uses a pre-built action.
      with:
	node-version: '14'

    - name: Install dependencies
      run: npm install				# Runs a shell command directly. 

    - name: Run tests
      run: npm tests 


-------------------------------------------------------------------------------------------------------------------



						Advanced Github Actions
				(Conditionals/Expressions and Matrix builds / Parallel testing)

-----------------------------------------------------------------------------------------------------------------------


							Conditions

- Control when a job/step should run based on a criteria. 

- name: Run tests
  run: python -m unittest discover		# This command only runs if previous steps succeeded. 
  if : success()				# This is the condition. success () means only run if all previous
						  steps succeeded.


							Expressions


- Perform calculations, Manipulate strings.
- Let's you do more within your pipeline
 
- name: Print branch name
  run: echo The branch is ${{ github ref }} 	# ${{ }} this is the expression. Allows you to perform logic/use values.


-----------------------------------------------------------------------------------------------------------------------


						Matrix Builds and Parallel Testing


- Allows you to run your github actions and therefore test across different environments. For example:
- This speeds up tests by running the same job multiple times in parallel.
- Code is very clear. Look below:

------------------------------------------------------------------------------------------------------------------


name: Matrix Build with OS and Python

on: [push]

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        python-version: [3.6, 3.7, 3.8, 3.9]

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Run tests
        run: pytest


--------------------------------------------------------------------------------------------------------------------


						Secrets and Encrypted vars


- Secrets are sensitive data/information that you do not want to expose in your codebase 
- Secrets allow us to keep our sensitive data secure. 
- Github will use secrets but will NEVER show them (will encrypt)

						How to setup github secrets

1. Go to github repositary
2. click on "settings"
3. On the left sidebar, click on "secrets"
4. Clock on "New repository secret"
5. Enter a name for your scret in the "Name"
6. Enter the value of thee secret in the "Value" field. Finally, add the secret.
7. Look at the example below at how to run a secret.


--------------------------------------------------------------------------------------------------------------------


jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    
    - name: Checkout code
    uses: actions/checkout@v2
    
    - name: use secret in a script
    run: echo "The secret is ${{ secrets.SecretName }}"		# Calling the secrets repositary directly. 
    
    - name: use secret as envrionment variable
    run: echo "The secret is $MySecret"
    env:
      MySecret: ${{ secrets.SecretName }}			# Set up the env variable form secrets repositary


--------------------------------------------------------------------------------------------------------------------



						

					Reusable CI/CD actions for workflows

- Re-usable units of code that automate specific tasks in pipeline.
- This section is based around creating custom actions and resuing them throughout your workflow.
- If you want, you can even make these workflows public/open source to help the community. 


Custom actions are a great way to automate parts of your project that are specific to your project.

Can create these actions in javascipt, docker or other sources.


3 types of custom actions:

- Javascript actions: Use node.js to run javascript code.
- docker actions: ran in containers
- custom actions: pieces that are re-usable


How to create a custom action?

1. Create a repositary to host custom action
2. Define action metadata in action.yml file
3. write the code for your action
4. Public your action to github market place (Option. Makes it public)

